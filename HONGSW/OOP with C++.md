# 객체지향 with C++
객체?   
절차지향의 한계 
죄다 포인터로 받아옴 - 함수작성시 인자로 주소값을 받아야함  
함수이름은 항상 다르게 작성 
프로그램확장불편    
- 필요한 함수를 명확하게 호출해야하고 수정사항이 생기면 변경할것들이 많음 이를 위해 함수포인터를 사용하거나 타입구분을위한 추가적인 데이터가 필요했음

## 객체지향 4가지 특성
>### 1. 캡슐화

무엇
- 데이터(멤버 변수)와 데이터를 다루는 함수(멤버 메서드)를 하나의 단위로 묶음
- 객체가 구현된 방식의 세부 정보를 사용자로부터 숨기면서 유지
        실제 구현내용 일부를 내부에 감추어 은닉   

언제
- 언제든

왜?
- 클래스 사용자 : 클래스 내부 구조 이해할필요없음, 사용법만 알면 사용가능, 데이터를 실수로 잘못 바꾸는 것 방지

어떻게
- 클래스 안에 멤버변수, 멤버 메서드 선언 / 접근 제어    
    접근지정자로 구분함
    * private - 자기 클래스 내부의 매서드에서만 접근허용
    * protected - 자기 클래스, 상속받은 자식 클래스 접근허용
    * public - 모든 접근허용    

this포인터?     

클래스내 정의된 데이터부분을 필드, 함수를 메소드 라고한다

>### 2. 상속     

무엇
- 부모 클래스의 멤버를 재사용해서 자식 클래스에서도 사용할 수 있음  

언제    
- 부모 클래스에서 할 수 있는 일을 자식클래스에서 할 수 있다.(Liskov 치환 원칙)    
    (부모클래스에서 할 수 있는 일을 과연 자식 클래스에서도 전부 할 수 있냐를 따져 상속관계 선정)
- 자식 클래스는 부모 클래스의 일종이다(A is a B)    

왜?
- 코드 재사용 위해

>### 3. 추상화

무엇
- 부모클래스 : 클래스가 구현해야 할 기능만을 명시(순수 가상 함수)
- 자식클래스 : 실제 구현

언제
- [자식 클래스]는 [부모 클래스]할 수 있어야 한다.(A is able to B)

왜?
- "자동차" : 운전대, 페달, 기어변속기 <- interface (추상클래스)  
        각 부품의 작동원리는 자동차 종류마다 다름, but 우린 운전할 수 있다.

어떻게
- 추상클래스(순수 가상 함수)

>### 4. 다형성(Polymorphism) 
무엇    
- 한 클래스가 그로부터 파생된 다양한 형태를 지닐 수 있음    
        (어떤객체를 가리키고 있냐에 따라 서로다른 메소드들이 실행될 수 있다.)

언제
- 자식 클래스의 메서드 구현이 부모 클래스와 다를 때

왜
- 자식 클래스에서 하고 싶은 일들이 부모 클래스에서와 다를 수 있음

어떻게
- 오버라이딩, 가상함수(동적바인딩을 하기 위해)  
        (RTTI, 다형적 클래스)

---

# C++ 프로그래밍

>### 1. 레퍼런스
레퍼런스는 간접참조를 편하게 쓰기위해 사용  

C에선 함수의 인자에 주소값을 전달하여 포인터타입을 통해 역참조하여 값을 바꿈    
c언어에서는 어떠한 변수를 가리키고 싶을땐 포인터를 사용.    
c++에선 다른 변수나 상수를 가리킬때 참조자라는 다른 방식으로도 사용 가능    
레퍼런스가 한번 별명이 되면 절대 다른이의 별명이 될수없다.  
 - 한번 어떤 변수의 참조자가 되면 더이상 다른 변수참조 불가능    
레퍼런스는 메모리상에 존재하지 않을 수 도 있다.
- 포인터는 8바이트를 차지하지만 레퍼런스는 굳이 따로 메모리상에 공간할당할 필요가 없다. 하지만 항상 그런건 아님
        
>### 2. 클래스
- 클래스는 청사진, 그걸 바탕으로 메모리에 표현한걸 인스턴스라 한다.     
모든인스턴스는 객체지만 모든 객체가 인스턴스가 아니다 

클래스타입은 기본적으로 갖는 메소드가있다. 이를 기본 합성 메소드 라 한다.   
생성자(constructors) - 인스턴스 초기화 담당 메소드  
초기화, 할당 구분   
소멸자 : 자원정리위해 사용, 객체 수명이 다할 때 자동호출    
기본생성자는 언제? 사용자가 어떠한 생성자도 명시적으로 정의하지 않았을경우 컴파일러가 자동으로 추가     
데이터 은닉 : 구현 세부사항에 사용되는 데이터를 외부에 노출하지 않는 것     
데이터은닉위반 -> 객체지향적 설계에 맞지않는다.     
생성은 부모 => 자식순으로   
소멸은 반대로 자식 => 부모 순으로 한다  
상속할 클래스를 : 뒤에 적어준다.    
다중상속 잘못하면 The Diamond Problem   

>## SOLID 5원칙
- 클린아키텍쳐에서 소개된 설계 5원칙

1. SRP 단일책임원칙     
객체는 한가지의 기능만을 가지며 관련없는 기능은 합치지않음
기존코드는 병경하지않으면서 기능은 추가가능한 설계
모듈은 변경의 이유가 하나 예를들어 이미지 기능은 이미지만 하게끔 설계해야한다.

2. 개방폐쇄법칙 OCP     
확장은 개방적, 수정은 폐쇄적
객체는 확장하는데 열려있고, 수정에는 닫혀있어야한다는 원칙으로
기존 코드를 수정하기보단 새로운코드를 추가하는 방식으로 시스템 행위변경이 가능하도록 설계해야 쉽게 변경이 가능하다.     
캡슐화와 관련이 깊다

3. 리스코프 치환원칙 LSP        
상위타입의 객체를 사용하다 하위타입객체를 사용해도 정상작동해야된다.    
즉 부모클래스에서 동작하는 기능은 자식클래스에서 확장은 될지언정 틀리게 동작해선 안된다.

4. 인터페이스 분리원칙 ISP      
범용의 인터페이스를 만드는것이 아닌 클라이언트에 특화된  인터페이스사용
즉 필요한 인터페이스만 분리해서 설계하는 원칙이다
클라이언트는 사용하지않는 메소들에 의존하게해선안된다
큰 인터페이스들을 작은단위로 나누는것이좋다
예를 들면 수륙양용차를 인터페이스화 시키면 지상에서 운전, 물위에서 운전하는 기능을 가지게되고 
이를 일반 차량에 적용시킬시 물위에서 운전하는 기능은 쓰지않지만 포함되게된다.
따라서 수륙양용차를 만들기위해선 차량인터페이스, 보트 인터페이스를 구상한뒤
두개를 합치는 방향으로 설계하는것이좋다.

5. 의존성 역전원칙 DIP(Dependency Inversion Principle)  
고수준묘듈은 저수준묘듈의 구현에 의존해선안된다.
추상화 모듈을 만들어서 고수준모듈, 저수준모듈이 추상화클래스에 의존하게 만들어서 유지관리쉽게 하는것이다.       
즉, 고수준모듈이 저수준모듈에 직접적인 의존성을 가지않는것이 가능하다.  
예를들어 동물원에 개와, 고양이가 있으면 동물원은 고수준모듈로 볼수있고, 개와 고양이는 저수준 모듈로 볼수있다.
동물원은 개와 고양이에 의존성을 띄게된다 고수준이 저수준을 포함하는게 직관적이고 당연시하다
여기에 양과 소를 추가하게 되면 동물원은 의존해야하는 코드가 많아지고 나중에 이를 수정할땐 불편하게 된다.
이를 위해서 의존성역전원칙을 사용한다.
동물이라는 추상화클래스를 만든뒤 동물원이 동물에 의존하게 만들고 개와 고양이가 동물에 의존하게 만들면 나중에 양과 소가 추가된다 하더라도 동물원은 직접적으로 수정할 필요가없어진다.