다른객체 참조필요할때 쓰는 방식 폴링, 옵저버패턴

폴링?
	- 일정 주기로 확인하여 조건을 만족할때 자료처리하는 방식
	수정이 빈번하게일어나면 폴링도 좋은 대안
	어쩌다가 드물게 변화가 일어나면 매번 확인은 비효율적이다
	변화가 일어나는 시점을 알수있는 패턴
		- 옵저버 패턴
		
옵저버패턴
	- 어떤 객체상태가 변할때 그 시점에 다른객체들도 자동으로 갱신될 수 있게 하는 패턴
	- 매번 검사하기보단 상태가 바뀌었을때 동작
	
	한 객체가 다른 객체에 종속적일때 사용가능
	종속되는 객체의 수를 알필요가 없어도될때 사용가능
	어떤 객체가 다른 객체에 변화 통지가능, 그 변화에 관심있는 객체가 누군지에 대한 가정이 없어도 될때 사용가능
	
	패턴의 구조 참고(https://ko.wikipedia.org/wiki/%EC%98%B5%EC%84%9C%EB%B2%84_%ED%8C%A8%ED%84%B4)
		Subject: 변화가 이뤄지는 주체
			Attach(observer)
			Detach(observer)
			Notify()
				- 관찰자에게 자신의 변화를 알려줌
		Obsever: 변화 관찰
			Update()
	
	구현방법
		Generic
		Push Model
			- 변화상태를 전달하는것도 subject가 같이 보냄
		Pull Model
			- observer가 알아서 깨냄
		Funcitional
			- 함수도 변수처럼 활용하는것
			- 관찰자면서 관찰대상
			- 다중상속
	
	c#에선 이벤트로 옵저버패턴을 쉽게 구현되어있다
	
	장점
	subject와 observer가 강하게 결합되지 않는다
		- 폴링은 객체가 멤버로 subject들고있어야함
		- 옵저버패턴은 계속들고있지 않아도된다
	브로드캐스트 가능
	예측하지 못한 데이터갱신가능
		- 종속관계복잡, 추적어려운 곳에서 갱신가능
	
	단점
	무효참조(Dangling Reference)가 일어날수있다
		> 무효참조: 무효한메모리주소(이미 수명이 끝난)를 가리키고있는것
		- 통지받으려면 subject등록해야함
		- 통지받고싶지 않을땐 해제를 해야하는데 어려움
		- 해지하지않으면 무효참조이슈 발생
	상태의 자체 일관성(self-consistency)이 깨질수있다
		- 서브클래스가 슈퍼클래스 연산을 사용하는 과정에서 통지 발생가능
	통지에 따른 갱신이 오래걸릴수있다
		- 통지 시점 병목될수있음
		- 완화를 위해 비동기방식, 큐잉 이용
		
	구독: += 연산자
	해제: -= 연산자
	
	UnityEvent: 유니티에서 구현한 옵저버패턴 타입(https://docs.unity3d.com/kr/530/ScriptReference/Events.UnityEvent.html)
	
	객체가아닌 필요한 메서드를 담아서 실행
	
오브젝트풀링?

사용이 다 됬으면 비활성화

delegate
	- 함수포인터(함수에 주소값을 담을수 있는 포인터)

unityAction
	유니티에서 쓰이는 delegate

c#의 이벤트는 객체를 만들지 않아도 된다.
	- new 필요오ㅓㅄ다
	- (?.)로 널체크를 해줘야한다
	구독방법
	+= 구독
	-= 해지