Transform.Translate 사용할때 x = v*t 공식을 사용해야한다
	> 구하고자 하는 좌표에 Speed * Time.deltaTime을 하면 초당이동거리 구할수있음
	
OnTriggerStay: 플레이어가 현재 죽었는지 살았는지 체크가능

자연스러운 움직임을 구현하기위해선 velociy나 가속도를 사용한다

상태전환부분은 함수로 만들어 따로 관리
로직은 업데이트에 담는다

OnTriggerStay보단 OnTriggerEnter, OnTriggerExit를 사용해 상태만 한번 업데이트 해주는 방식으로 구현하는게 좋다

Quaternion: 회전을 위한 함수
	Quaternion.Identity?
		- 
	Quaternion.LookRotation(백터값)
		- target기준으로 회전
	Quaternion.Slerp(쿼터니안 A, 쿼터니안 B, t)
		- A에서 B로 회전, 회전속도는 t
		- 오브젝트가 target을 서서히 회전하여 바라봄
		
캔버스
	- 모든UI요소는 canvas안에 위치해야함(캔버스의 자식인 UI요소)
	- UI요소가 겹쳐지면 나중에 그려지는것이 먼저 그려진것의 위에 나타남(순서존재)
	- 순서는 Transform컴포넌트 메서드를 사용해 스크립팅으로 제어가능
	
	스크린공간
		- 오버레이
			- 해상도 변경되면 자동조절가능
		- 카메라
			- 오버레이와 유사
			- 특정카메라에서 주어진 거리만큼 앞에 위치
			- 원근감 느껴짐
	월드공간
		- 캔버스는 씬에 있는 다른 오브젝트처럼 동작함
		
	tranform / rect transform 차이는?
	
	피벗
		- 회전, 크기, 스케일은 피벗의 영향을 받는다
		- 피벗 범위 0 ~ 1
	
	앵커
		- 레이아웃을 위한 개념
		- 중심위치표시
		- 앵커 포지션은 부모사각형의 폭과 높이에 대한 비율로 정의
		
	패널?
		- 백그라운드를 그리거나 뭔가를 꽉 채워서 보여줘야할때(튜토리얼창 등등)
	
	상호작용 컴포넌트
		- 사용자가 선택가능
		- 키보드, 마우스, 컨트롤러를 사용해 상태전환기능 시각화
		
캔버스 스케일러 
	- 반응적인 UI구성가능
	
씬 로드엔 로드씬을 적거나 씬빌드세팅을 해주면된다.

싱글톤패턴?

PlayerPrefs?

저장 set, 가져올땐 get

TextMeshProUGUI 와 TextMeshPro 헷갈리지 말기

프로젝트를 진행하면서 힘들었던점
프로젝트구현중 가장 공들인 기능
프로젝트 진행하면서 아쉬웠던점