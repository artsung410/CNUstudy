람다식: 익명메소드를 만들기위해 사용
	매개변수_목록 => 식
	=>: "입력" 연산자

===

캡슐화
	- 데이터와 데이터를 다루는 함수를 같이 작성
	
상속
	- 코드물려받기. 코드재사용가능(단순히 코드 재사용을 목적으로 사용하는것은 아니다. [하위] is a [상위]를 만족시켜야한다)

추상화
	- 구현세부정보숨기기 -> 인터페이스를 정의하는 행위
	
다형성
	- 여러가지 형태를 가짐(가상함수를 통해서 구현)

객체지향 설계
	객체지향적 설계를 위해선 "메시지"를 만들고 이를 통해 서로서로 연관시켜줘야한다
	- 객체지향 설계의 핵심은 메시지
	- 메시지 전달을 코드로 표현하려면 메소드를 호출하면된다.

메시지를 통한 설계 == 함수를 언제 호출할지 설계
	-> 이벤트사용
	
동적생성콜라이더 확인
	window - physics debug확인

physics.overlap?

Vector3.Distance(a, b) 
	- 벡터 a와 b 사이의 거리
	
translate 매개변수중 어떤좌표계를 기준으로할지 정할수있다
	Space.self -> 자기자신기준
	Space.world -> 월드좌표기준
	
대리자 delegate
	- 함수포인터와 비슷한 참조타입 즉, 함수를  보관할수있는 타입
	- 사용자 정의 대리자를 만들수도있지만 System.Action 혹은 System.Func를 사용한다
	- 유니티에선 UnityAction도 사용할수있다
	- Invoke() 메소드로 보관된 모든 함수를 호출할수있다.
	
	[접근한정자 delegate 함수타입 함수이름(매개변수)]
	private delegate void Foo();
		- void()타입의 함수만 보관가능
		-> 타입을 정의한것
	대리자타입의 객체를 만들려면
		public Foo fooObject;
		fooObject에는 void()타입의 함수를 넣을수있다
			void temp();
			fooObject += temp; 구독
		
	delegate int Boo();
		- int()타입의 함수만 보관가능
	
	delegate float Gee(int, float);
		- float(int, float)타입의 함수만 보관가능
		
Action과 Func
	- 둘의 차이는 반환값의 유무
	Action은 void타입의 함수만 담을수있다
	Action과 Func둘다 매개변수를 최대 16개 까지 넣을수있다
	
이벤트 event [delegate 타입] 이름;
	-> 객체가 만들어짐
	- 옵저버패턴을 쉽게사용하기위한타입
	- 선언된 대리자 타입의 함수를 보관할수있다.
	- 대리자와 다르게 외부에서 Invoke를 할수없다
	- 함수가 중복되어 추가된다면 디버깅이 어렵기에 추가전에는 꼭 삭제를 먼저 해준다
	- 이벤트 객체에 아무런 함수도 없는 경우에는 null이기에 I nvoke를 호출할때는 null체크를 해준다
		> Ex) OnTakenDamage?.Invoke();
			- 참고로 대리자는 null체크할 필요없다 대리자는 무조건 담겨있기때문에
	- 활용법은 특정사건(혹은 시점)을 나타내며, 그 시점에 일어나야 하는일(코드상 메소드로 표현)들을 실행할수있다
	
	*주의사항*
		1. 특정시점이 됐는데 Invoke()호출을 빼먹은경우
		2. Invoke될때 실행되어야 할 메소드를 추가하지않은경우
	
Action 타입의 객체
public event Action OnSomething; -> void()타입의 함수만 담긴다.

event와 대리자의 차이
	- event는 내가만들어진 타입에서만 invoke가능
	- 대리자의 경우 외부에서도 invoke가능
		-> 의도하지않을때에도 호출이될수있다
대리자는 그냥 함수만 보관하는 타입이기 때문에 외부에서 호출될수있다
	-> 결론: 둘다 함수를 보관하고 삭제할수있지만 제일큰차이점은 외부접근차이다
	
