문제해결을 위해 먼저 생각해야할것은 필요한 데이터가 뭔지 생각해야한다.
그 데이터를 어떻게 조직하느냐에 따라 시간복잡도 차이가 많이난다.
이러한 데이터조직법을 자료구조라고 한다.
데이터 조직에 적합한 알고리즘을 선택하는것이 중요하다.

재귀 - 함수가 자기 자신을 호출하는것
재귀의 단점으론 호출에따른 오버헤드가 있고 너무 깊어지면 스택오버플로가 발생한다.
	오버헤드: 어떤 처리를 하기위해 들어가는 간접적인 처리 시간.메모리 등을 말한다.
	스택오버플로: 스택이 가용할 수 있는 공간을 벗어나는것을 말한다.
	
순차자료구조
	메모리 연속저장
	임의원소 즉각 접근가능
	캐시 지역성효과로 모든데이터 순회 빠름
		지역성: cpu가 기억장치 특정부분에 위치한 데이터나 코드를 집중적으로 엑세스 하는 현상
	데이터크기만큼 메모리 사용
	
연결자료구조
	데이터는 노드에 저장, 노드는 메모리 곳곳에 흩어져있음
	임의 원소 접근은 선형시간복잡도를 가짐. 느린편
	캐시 지역성효과 없음
	노드에서 포인터 저장을 위해 여분의 메모리사용

알고리즘분석은 자원의 사용량을 분석하는것이라 볼수있다.(자원: 시간, 메모리사용량)

시간복잡도를 표기할땐 점근적 표기법을 사용한다.
	점근적표기법은 상수나 중요하지않은 항목을 배제한다.
Big-O표기법은 점근적 상한선을 제공한다.
알고리즘의 분석결과를 말할땐 최악의경우를 말한다.
빅오표기법을 쓰는 이유는 상한선이 존재하므로 최악의 경우를 말하기 유용하다.
빅오는 정확한시간이아니라 대략적인 시간복잡도를 나타낸다.
빅오의 시간복잡도 관계는 항상 옳은가?
	그렇지않다.
	어느시점을 기준으론 순서가 바뀔수있다.
	그 시점을 알기위해선 입력의크기를 어느정도로 잡을지 생각하고 시간복잡도를 그래프상에 나타내서 선을 그려본다.
	
공간복잡도 - 알고리즘을 수행하는데 필요한 자원 공간의 양
고정공간요구 + 가변공간요구

공간과 시간은 반비례. 보통은 시간위주로 판단.

읽기 검색 삽입 삭제

선형리스트
	- 읽기
		- 연속적이다.
		- 임의접근 가능 O(1)
		- 주소연산 가능
	- 검색
		- 하나하나 비교 O(n)
		- 정렬되어있으면 이진검색가능 O(logN)
	- 삽입
		- 맨끝 O(1)
		- 처음, 중간 O(n)
		
이진검색
	- 검색할 범위를 절반으로 줄여가며 검색
		- 중앙값 기준, 검색할필요없는부분 날림
	- 정렬된 선형리스트에서 사용
	
연결리스트
	- 읽기
		- 흩어져있음
		- 임의접근 불가능
		- 하나하나 탐색 O(n)
		- 단, 처음과 끝이라면 구현에 따라 O(1)
	- 검색
		- 하나하나 비교 O(n)
		- 이진검색 불가능
	- 삽입
		- 앞, 뒤 추가시 O(1)
		- 중간추가시 위치까지 검색필요 O(n)
	- 삭제
		- 삽입과 동일하다.
		
	종류
		- 단일 연결리스트
			- 다음원소로만 이동 forward_list
			- 하나의 연결부
		- 이중 연결리스트
			- 이전, 다음 모두 이동가능
			- 연결부가 두개다
		- 원형 연결리스트
			- 마지막원소와 첫번째 원소를 연결한 형태
			- list는 이중 원형 연결리스트
			
스택
	- 리스트의 일종
	- 연산이 한 쪽 끝에서만 이뤄짐
	- LIFO구조
	- 괄호검사 / 후위 표기식 / DFS
	
큐
	- 리스트의 일종
	- FIFO구조 (선입선출)
	- 삽입부를 뒤, 삭제부를 앞
	- 프린트 큐 / CPU 스케줄링 / 데이터버퍼 / BFS
	
데크
	- Double-ended Queue
	- 삽입 삭제가 양 끝에서 가능
	- 선형리스트와 연결리스트를 조합한 청크리스트
	- 효율적인 연산
	- 컨테이너 어뎁터의 기본 자료구조
	
그래프
	- 조직도, 계층, 관계도
	- 비선형적, 관계특화 자료구조
	- 정점
		- 고유하게 식별되는 객체
	- 간선
		- 정점간의 관계
	종류
		- 간선의 방향성여부
			- 방향그래프
			- 무방향그래프
		- 가중치 여부(간선이 단순 연결 이상의 정보를 가짐)
			- 가중치 그래프
	- 경로
		- 한 정점에서 다른 정점까지 간선으로 연결된 정점을 순서대로 나열한 리스트
	- 경로길이
		- 경로구성 간선 수
	- 단순경로
		- 모두 다른 정점으로 구성된 경로
	- 사이클
		- 단순 경로 중 경로의 시작 정점과 마지막 정점이 같은 경로

인접행렬표현
	정점N개 N*N크기의 2차원 배열로 그래프를 표현할수있다
	배열의 원소는 간선의 가중치를 나타낸다.
	graph[i][j]는 정점 i에서 j로 가는 간선을 나타낸다.
	그래프에 간선이 적다면 메모리 낭비하게됨
		- 희소그래프: 적은 간선을 가진 그래프
		- 밀집그래프: 많은 간선을 가진 그래프

	graph[0][1] = 1
	graph[1][0] = 1
	
	graph[1][2] = 2
	graph[2][1] = 2
	graph[1][3] = 2
	graph[3][1] = 2
	
	graph[2][5] = 6
	graph[5][2] = 6
	graph[2][6] = 3
	graph[6][2] = 3
	
	graph[3][5] = 4
	graph[5][3] = 4
	graph[3][4] = 1
	graph[4][3] = 1

인접리스트로 표현
	각 정점에 연결된 정점의 ID만 저장하는 방식
	벡터로 표현 할 수 있으며 구현난이도 증가
	vector<Edge> graph[7]
		- 벡터의 크기는 진출 차수와 같다
	[index]: 연결된 정점
	인접리스트 가중치 표현
		- (간선, 가중치)
		
순회(탐색)
	한 정점에서 시작해 그래프의 모든 정점을 한번씩 방문
	- 깊이우선탐색(DFS)
		- 더이상 갈수없을때까지 전진
		- 막다른곳이면 갈림길로 돌아와 다시 탐색
		- 스택 or 재귀함수를 이용한다
	- 너비우선탐색(BFS)
		- 시작정점에 인접한 정점을 모두 차례로 방문
		- 방문했던 정점을 시작으로해서 다시 모두 방문
		- 큐를 사용한다
		