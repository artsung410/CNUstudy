디자인 패턴
	- 설계패턴과 일맥상통
	- 객체지향적 설계를 도와주기위한 패턴
		> 객체지향
			- 객체들로 프로그램을 구성
				> 객체
					- 상태 + 행동을 가지고 있는 어떤 존재
					- 행동 = 객체의 기능
					- 상태 = 데이터
					- 객체가 될수있는 존재 -> 현실세계에 존재하는 실체적인것 + 추상적인 모든것
				이러한 현실세계 모델링 특징으로 주류가 되었다
					- 추상화
						- 일반적인 인터페이스 정의
					- 상속
						- 코드 물려받음, 재사용
					- 다형성
						- 하나의 인터페이스로 다양한 동작
					- 캡슐화
						- 데이터와 함수를 함께 적을수있다
	- 설계할때 특정 맥락에서 자주 발생하는 문제들이 또 발생했을 때 재사용 할 수 있는 해결책
	- 패턴이란 유사한 설계문제와 해결책들을 말함
	
	생성패턴
		- 객체의 생성
	구조패턴
		- 아키텍처설계에 종속되지않으면서 다양한 설계
	행동패턴
		 - 동작관련부분
	
싱글톤(단일체) 패턴
	- 오직 한개의 인스턴스만을 갖도록 보장
		> 인스턴스 : 클래스를 기반으로 만들어낸 데이터 덩어리
	- 전역적인 접근점 제공 -> 어디서나 접근가능
	- GetInstance()사용
	- 싱글톤이 되려고하는 클래스는 싱글톤클래스를 상속받으면 된다
	
	장점
		- 인스턴스의 유일성보장
			- 컴파일단계에서 강제
			- 인스턴스 개수 늘리고자 할때 유연하게 변경가능
		- 게으른 초기화 일어남
			- 계산 평가가 lazy하다
			- 런타임에 초기화
		- 어디서든 쉽게 접근가능
			- 전역적인 접근점 제공
		- 이름공간을 좁힌다
			- 이름공간대신 클래스 이름공간사용(이름공간 깔끔)
			
	단점
		- 전역변수다
			- 결국 전역적인 접근점을 제공하기에 전역변수와 비슷한 문제(코드의 결합도가 높아짐 -> 유지보수 힘듬)존재, 스레드 동기화 문제
		- 게으른 초기화 방지할 수 없다
			- 초기화에 오랜시간소모
		- 두가지 문제를 풀려고한다
			- 유일성보장과 동시에 전역적인 접근점도 제공(?)
	
	고려사항: 싱글톤은 제한적으로 사용해야한다
		- 클래스 필요여부확인
			- 객체자체가 판단 할 수 있는 것은 객체에 캡슐화해야한다
		- 정적변수를 이용해 인스턴스 개수 제한가능
			- 다만, 런타임에 평가하는것이 단점
		- 전역적인 접근점 대신 다른 방법 사용
			- 의존성 주입 사용
				> 의존성주입: 매게변수를 이용해 의존성을 넘겨주는 방식
			- 상위 클래스 이용
				- 상위클래스에 정적변수를 만들어 하위 클래스에서 사용할수있게하면 전역변수를 사용하지 않고도 계층구조를 통해 그와 비슷하게 사용할수있다
			- 이미 전역인 객체 이용
				- 기존 전역겍체에 정적변수를 만들어 이용하게할수있다
			- 중재자패턴 사용
				- 구체 클래스를 직접 사용하는 대신 중재자로 결합도 낮출수있다
		- 모노스테이트활용
			- 모든 멤버나 혹은 필드만을 정적으로 두는것
			ex) 유니티의 Time클래스나 Random클래스 생각
			
	싱글톤 인스턴스를 참조하는 경우에도 직접 가져도 쓰기보다는 다른 식으로 우회하여 결합도를 낮출방법모색
	
	유니티 제어구조 받는 단일구조 ㅗ잰배ㅣㅁ
						
제네릭(C#)은 템플릿(C++)보다 자유도가 조금 떨어진다.

속성
	- 필드의 확장버전
	- 적은 코드로 필드와 관련된 메서드 작성가능
	
다른객체 참조필요할때 쓰는 방식 폴링, 옵저버패턴
폴링?
	- 일정 주기로 확인하여 조건을 만족할때 자료처리하는 방식
	수정이 빈번하게일어나면 폴링도 좋은 대안
	어쩌다가 드물게 변화가 일어나면 매번 확인은 비효율적이다
	변화가 일어나는 시점을 알수있는 패턴
		- 옵저버 패턴
		
옵저버패턴
	- 어떤 객체상태가 변할때 그 시점에 다른객체들도 자동으로 갱신될 수 있게 하는 패턴
	- 매번 검사하기보단 상태가 바뀌었을때 동작
	
	한 객체가 다른 객체에 종속적일때 사용가능
	종속되는 객체의 수를 알필요가 없어도될때 사용가능
	어떤 객체가 다른 객체에 변화 통지가능, 그 변화에 관심있는 객체가 누군지에 대한 가정이 없어도 될때 사용가능
	
	패턴의 구조 참고(https://ko.wikipedia.org/wiki/%EC%98%B5%EC%84%9C%EB%B2%84_%ED%8C%A8%ED%84%B4)
		Subject: 변화가 이뤄지는 주체
			Attach(observer)
			Detach(observer)
			Notify()
				- 관찰자에게 자신의 변화를 알려줌
		Obsever: 변화 관찰
			Update()
	
	구현방법
		Generic
		Push Model
			- 변화상태를 전달하는것도 subject가 같이 보냄
		Pull Model
			- observer가 알아서 깨냄
		Funcitional
			- 함수도 변수처럼 활용하는것
			- 관찰자면서 관찰대상
			- 다중상속
	
	c#에선 이벤트로 옵저버패턴을 쉽게 구현되어있다
	
	장점
	subject와 observer가 강하게 결합되지 않는다
		- 폴링은 객체가 멤버로 subject들고있어야함
		- 옵저버패턴은 계속들고있지 않아도된다
	브로드캐스트 가능
	예측하지 못한 데이터갱신가능
		- 종속관계복잡, 추적어려운 곳에서 갱신가능
	
	단점
	무효참조(Dangling Reference)가 일어날수있다
		> 무효참조: 무효한메모리주소(이미 수명이 끝난)를 가리키고있는것
		- 통지받으려면 subject등록해야함
		- 통지받고싶지 않을땐 해제를 해야하는데 어려움
		- 해지하지않으면 무효참조이슈 발생
	상태의 자체 일관성(self-consistency)이 깨질수있다
		- 서브클래스가 슈퍼클래스 연산을 사용하는 과정에서 통지 발생가능
	통지에 따른 갱신이 오래걸릴수있다
		- 통지 시점 병목될수있음
		- 완화를 위해 비동기방식, 큐잉 이용
		
	구독: += 연산자
	해제: -= 연산자