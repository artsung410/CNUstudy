LINQ
	from
		데이터원본, 범위변수를 지정
			범위변수: 쿼리변수라고도 함, 데이터 원본안에 들어있는 각 요소데이터를 나타낸다
		from절을 이용해 범위변수를 뽑아낸후 데이터가공및 추출가능

	where
		필터역할
		범위변수가 가져야하는 조건을 인수로 입력

	orderby
		데이터 정렬수행
		인수로 정렬의 기준이 될 항목기입
		orderby ~ ascending -> 오름차순
		orderby ~ descending -> 내림차순

	select
		최종결과 추출
		LINQ질의결과는 IEnumerable<T>로 반환, 이때 형식 매개변수 T는 select문에의해 결정
		select문은 무명형식 -> 새로운형식 즉석생성가능
			- 무명형식
				형식의 선언과 동시에 인스턴스를 할당 -> 인스턴스를 만들고 다시는 사용하지않을때 요긴함
				ex) var myInstance = new { Name = "최문선", Mode = "Computational Thinking Mode" };
				프로퍼티에 접근하여 사용가능
				할당된값은 변경불가능 -> 인스턴스가 만들어진후엔 읽기만 가능
	
	기본적인 형태론 from문으로 데이터 원본과 범위변수를 지정하고 where를 사용해 범위변수 조건을 기입한후 정렬할 필요가 있을경우 orderby로 정렬한후 select문을사용해 최종결과를 추출한다
	
여러개의 데이터원본에 질의하기
	여러개 데이터원본에 접근하려면 from문을 중첩해서 사용한다
		
group by
	분류기준에 따라 데이터 그룹화
	
	group A by B into C
		A: 범위변수
		B: 분류기준
		C: 그룹변수
	그룹변수에는 조건에맞는 객체의 컬렉션이 입력
	select문이 추출하는 새로운 무명형식은 컬렉션의 컬렉션이된다
	
join
	두 데이터 원본에서 특정필드의 값을 비교한후 일치하는 데이터끼리 연결
	왼쪽조인만 지원
		왼쪽조인이란? 왼쪽데이터원본을 기준으로 삼아 조인수행
	내부조인
		교집합과비슷
		첫번째 데이터 원본과 두번째 데이터원본의 특정필드 비교후 일치하는 데이터 반환
		기준은 첫번째원본데이터
		기준데이터 원본엔 존재하나 연결할 데이터 원본엔 존재하지않는 데이터는 결과에 포함되지않음
		반대도 마찬가지다
		from a in A
		join b in B on a.xxx equals b.yyy
		a: 범위변수
		b: 연결대상데이터
		on: 조인조건수반 조건은 equals만 허용된다.(비교연산 x)
		
	외부조인
		조인결과에 기준이 되는 데이터원본이 모두포함됨
		일치하는 데이터없으면 빈칸으로 채움
		조인결과를 임시컬렉션에 저장
		임시컬렉션에서 from절을 한번더 수행하여 범위변수를 뽑아냄
		
		
=======

면접단골질문!!

최적화관련 

<CLR C# 과 Unity  C#의 차이>
C#
	소스코드하나로 다양한 멀티플랫폼대응하고 싶다 -> 자바가 나온 배경
	C#은 자바를 본따 만들었다
	마이크로소프트에서 개발한 완전객체지향 언어다. 그래서 클래스를 무조건 하나이상 포함시켜야한다
	람다식, 비동기프로그램등등 새로운기능 다수존재
	.NET아키텍처를 알아야한다
	미들웨어프로그램을 만들어야 다양한 플랫폼에 대응할수있다
	운영체제위에 미들웨어프로그램위에 C#이 올라가있는 형태로 존재한다
	.NET아키텍처는 C#을 다양한 플랫폼에서 동작시킬수있도록 사용하는 공용언어인프라다
	
	C#은 컴파일하면 CLI사양을 준수하는 중간언어로 컴파일됨
	이런 IL코드와 리소스가 함께 패키징되어 어셈블리된다.
		어셈블리
			- 서로함께사용되어 논리적기능단위를 형성하도록 빌드되는 타입 및 리소스의 컬렉션
			- 실행파일(.exe), 동적연결라이브러리(.dll) 확장자를 가진다
	어셈블리가 CLR에 로드 -> CLR은 IL코드를 플랫폼에 따라 JIT컴파일, AOT컴파일 수행
		- JIT프로그램중에 컴파일 진행(인터프리터 ex. 파이썬)(파이썬 그는 신이야!)
	
	여러 .NET언어를 지원하기위해 공용타입시스템 지원
	
	C#값 타입은 구조체 / 열거형 / 그외에 기본제공타입으로 구성됨
	- 구조체를 제외한 모든타입은 valueType에서 파생
		- 벡터는 구조체
	- 스택메모리에 직접 값이 포함됨 -> 복사일어남
	- 상속불가
	- 구조체 멤버중 참조타입이있다면 메모리주소가 복사 => 얕은복사
	
	참조타입은 클래스/ 대리자/배열/인터페이스가 있다
	- 힙메모리에 저장됨
	
	박싱
		- 값타입을 obj타입 또는 값타입에서 구현된 임의의 인터페이스타입으로 변환하는 프로세스
		int i = 10 -> valueType
		object o = i -> valueType -> reference type => boxing
		
	언박싱
		- 박싱된 인스턴스에서 값타입을 추출하는 프로세스
		int i = 10 -> valueType
		object o = i -> valueType -> reference type => boxing
		int a = (int)o; -> unboxing 상자를 벗겨낸 꼴이다
	박싱이 일어날땐 새로운 인스턴스를 생성해 힙으로 값을 복사, 언박싱은 힙에서 스택으로 값복사
	박싱은 암시적, 언박싱 명시적
	박싱과 언박싱은 많은계산과정을 필요로한다
	박싱의경우 30배, 언박싱은 1.1배 따라서 잘안씀 왜 Generic을쓰는지 이해가 되는지
	
	c++에서는 동적할당된 메모리를 전부사용했다면 시스템에 돌려줘야한다
	메모리누수
		- 메모리사용하고서도 해제하지않았을때
	이중해제
		- 해제된 메모리를 다시 해제
			- 헤재된 메모리를 가리카는 포인터를 댕글링포인터라한다
	섣부른해제
		- 사용이 끝나기전에 해제
	이러한 불편함을 해결하기위해 자동메모리관리기술 가비지컬렉션 사용
	
	가비지컬렉터가 사용되지않는 메모리를 재사용한다
	객체의사용유무'가정'하기
		추적가비지컬렉션
			- 도달가능성으로 생존결정(루트를 사용해 도달되지못한 메모리는 가비지로 가정)
	
		참조카운팅
			- 해당메모리에 참조하는것이 없을때 가비지로 가정
			순환참조
				- 서로 다른 두 메모리가 서로를 참조
				이를방지하기위해 약한참조 개념을 사용함
				
	가비지컬렉션을 지원하는 언어를 매니지드언어라 한다.
		- 매니지드언어 반대를 언매니지드언어라한다
	
	
	세대를나눈이유는 효율성
	최근에만들어진객체 == 임시데이터 -> 수명 짧음
	오래전에 만들어진객체 -> 수명김
	메모리할당은 0세대에서만 최근에 만들어진 객체끼리 서로연관되는 경향이 있어 캐싱측면에서 좋다
	
	참조타입의 객체는 매니지드힙의 0세대에 할당
	메모리를 미리 시스템으로부터할당받아 놓기때문에 스택만큼 빠르게 할당 및 접근가능
	
	세대별가비지컬렉션 추적방식을 사용하는 C#
	매니지드힙을 검사해 찾으면 접근할수있는객체를 압축(?)해 가비지의 공간을 덮어버림(LOH는 압축안됨)
		- 즉, 단편화된 메모리가없게끔 복사해서 채워넣음
	이 과정에서 주소값을모두수정, 각 세대의 시작을 가리키는 포인터또한 수정
	
	가장먼저 가비지컬렉션이 일어나는 세대는 0세대.
	가비지가아닌 메모리는 윗 세대로 승격시킨다
	만약 0세대에서 가비지컬렉션을 수행했음에도 불구하고 새로운 객체를 만들기위한 메모리공간이 충분하지않다면 1, 2세대 순으로 수집 그럼에도 불구하고 부족하면 2, 1, 0순서로 수집수행
	2세대제외하곤 승격일어남
	
	가비지컬렉션은 멀티스레드 환경인 경우 가비지컬렉션이 수행되는 동안 다른 스레드가 중단됨
		- 참조카운팅 방식으로 가비지 수집이 일어나지 않는다
		- 필요하다면 약한참조 사용
		- 빈번한 할당 조심
		- 너무 큰 객체 할당 피하기
		- 복잡한 참조 관계피하기
		- 관리되지 않는 리소스 있음
	
	누구나 나만의 CLR, .NET을 만들수있다(할수있으면)
	Unity에서 사용하는 .NET은 Mono, IL2CPP 두가지가 있다.
	표준이 아니기때문에 차이가 발생한다.
	기본적으론 Mono사용하지만 일부 플랫폼빌드시 IL2CPP를 사용한다
	
	이처럼 .NET환경이 다르기에 가비지컬렉션도 다름
	Boehm GC를 사용하며 세대별로관리되지않고 메모리압축또한 일어나지않는다
	그래서 메모리 단편화가 일어나 힙이 쉽게 확장되어서 최적화이슈가 발생할수있다
	그리고 너무많은 성능이 소모되는걸 막기위해 수행제한시간을 두고 조금씩 증분하는 방식을 사용한다
	
===
.NET
	- CLR과 클래스 라이브러리 세트를 의미함
	- CLR은 C#코드를 컴팡ㄹ한 결과물인 IL코드를 다시 해당 플랫폼에 맞는 코드로 변환하여 하나의 소스코드로 여러플랫폼을 지원함
	- .NET에는 공용 타입 시스템이 있다
		> 모든 타입은 값타입, 참조타입으로 분류
		> 모든 타입은 System.Object타입을 상속받음
		> 이를 명확히 인지하고, 박싱과 언박싱을 피하도록 코드작성해야함

가비지 컬렉션
	- 메모리를 수동으로 관리하는 것은 여러문제점이 있다
		> 메모리 누수 / 이중해제 / 섣부른 해제
	- 메모리를 자동을 관리하는 기술
	- 가비지로 가정하는 방법
		> 추적방식: 도달 가능성으로 가비지 판단
		> 참조카운팅: 참조 횟수로 가비지 판단
	- 표준 .NET은 세대별 가비지 컬렉션 사용
		> 메모리 할당은 0세대에서만 일어난다
		> 메모리 해제 시, 가비지가 아닌 메모리는 윗세대로 승격
	- 가비지 컬렉션이 수행되는 동안은 프로그램이 멈추므로 이에 유의하여 코드작성
	
.NET: Unity
	- Unity의 스크립트 백엔드(스크립트 환경)에는 Mono, IL2CPP 두가지존재 -> 여기서 차이가 발생
	- Unity에서 가비지 컬렉션은 Boehm GC를 사용 
		- 세대별로 관리하지 않으며, 메모리 압축없기 때문에 메모리 단편화가 쉽게 일어나고, 힙도 쉽게 확장된다. 이러한 이유로 최적화 이슈가 발생할수있다.