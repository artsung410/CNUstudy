자료구조와 알고리즘

자료구조 선형/ 비선형
구현방법 순차/ 연결
순차 - 배열
연결 - 노드

연결자료구조(노드)
베이스가되는 선형리스트, 연결리스트를 잘. 아주 잘 알고있어야한다.

선형리스트는 임의접근이 가능하다
(임의 접근이란? 임의적으로 어떤걸 선택하더라도 바로 접근가능한것)
주소연산이 가능한이유는 메모리가 연속적으로 할당되기때문에 선형리스트(배열)에선 임의 접근이 가능하다
원소하나당 차지하는 크기(타입)를 알고있으면 시작주소로부터 주소연산하여 임의접근이 가능하다

연결리스트는 임의접근이 불가능하다
데이터들이 파편화 되어있기때문에

	- 읽기
	임의접근 불가능하므로 순차적으로 하나하나탐색해야함 O(n)의 시간(선형시간)이 걸린다. 하지만 처음과 끝이라면 O(1)이 될수있다.
	
	- 검색
	읽기와 같이 하나하나 비교하므로 O(n)시간이 걸림
	
	- 삽입
	앞, 뒤의 경우는 구현에따라 바로 접근가능. 중간위치는 O(n)
	하지만, 정확히 위치를 알고있으면 O(1)이다. 그냥 포인터 할당만 바꾸면되므로
	
	- 삭제
	삽입과 동일한 시간, 삭제도 정확히 위치를 알고있으면 삽입과 동일하다
	
forward_list는 다음원소로만 이동하는 단일연결리스트다
오로지 바로 앞의 노드밖에 모른다
순차적이지 않으므로 rbegin, rend가없다
크기를 계산하지 않는다 : size()없음

========== c++의 발전방향? ============
발전이 8년이나 멈추면서 자연어의 형태와 멀어짐
cpu바로 위에 c++파일이 올라감
다른언어는 cpu위에 인프리터가 있고 그 프로그램 위에 언어가 있다.
그래서 c++은 존내 빠름
런타임에 계산하는걸 컴파일타임에 함???
빌드버튼을 누르면 바로 프로그램이 돌아간다.
와 신기하다...
=====================================

list는 이전 원소로도 이동할수있는 이중 연결리스트다

디자인패턴
설계하면서 나온 비슷한패턴들을 모아놓은것들

list쓰는 이유?
	데이터가 순서대로 저장된다는 점

list.erase(iter)
위치한곳 데이터 삭제후 iter를 반환한다.
반드시 반환되는 iter를 받아서 갱신하는 방식으로 구현해야한다.

여러개의 데이터가있을때 자료구조의 특징을알고 문제에대한 정확한이해를 바탕으로 자료구조를 선택해야한다.
즉, 어떤문제든 적절한 자료구조를 잘 선택 할 줄 알아야 한다.

단일 연결리스트는 다음원소로만 이동가능하다 여기에 forward_list있음

이중연결리스트는 왔다갔다 가능하다


list는 이중원형리스트에 해당한다.

6/22====================================

새로운 루프문
range-based for loop
	- 컨테이너 순회시 반복자 타이핑 귀차니즘 해결
	
선형리스트는 임의의 중간값을 찾기엔 비효율적이다

endl; 아주아주 느리다.

입출력이 느린 이유
	cpu와 거리가 아주멀기 때문이다.

플러시
	버퍼에 저장되있던걸 다른 세컨드메모리로 모두 내보내는역할
	endl은 플러시 과정을 거쳐서 느림

-복습-
리스트는 순서를 갖고 있는 자료구조
std::array는 정적배열, 배열과 사용유사

std::vector 동적배열, 용량부족시 2배로 늘린다.

연결리스트는 선형리스트와 다르게 임의접근이 불가능하다. 주소를 알아낼수없기때문에
단일연결리스트
이중연결리스트
원형연결리스트

리스트를 사용하려면 순서를 가지고있는지 확인해야한다.
순서가 필요하다면 리스트 자료구조를 사용하자

연결리스트는 메모리가연속할당이 안되서 캐싱손해봄
cpu와 메모리 거리문제로 중간다리 캐쉬존재

프로그램이 데이터에접근할때 비슷한곳만 접근 -> 지역성
이런 지역성을위해 나온 부품이 캐시임

캐시에 cpu가원하는 데이터가잇다 - 캐시히트
없다? - 캐시미스
성능높이기는 캐시히트를 올리는것
최대한 지역변수를 활용하자

연결자료구조는ㄴ 캐시미스가 많이나는구조다

왜 리스트성능이 떨어지는가? 설명가능? 설명하면 면접프리패스임

스택, 큐(container adapter)
	리스트의 일종이다. 연산을 조금 제한했다.
	adapter? 컨테이너 함수사용을 그냥 가져와 제한을둠

스택
	last in first out 구조
	리스트의 일종으로 연산이 한 쪽 끝에서만 이뤄지는 자료구조
	끝을 위로두고 시작을 밑으로 둠
	괄호가 올바른지 검사 / 후위 표기식 / DFS 등에 사용
	
6/24===================================================
큐(queue)
	first in first out 구조
	삽입쪽을 뒤, 삭제부분을 앞이라 한다
	프린트 큐 / CPU 스케줄링 / 데이터 버퍼 / BFS 등에 사용
	
deque
	double-ended queue
	삽입과 삭제를 양쪽에서 가능하게 만들어준 구조
	컨테이너이기 때문에 반복자를 가진다.
	
	
선형리스트에서 데이터 삽입삭제는 비효율적이다
중간에서 작업할시 크기조절 필요
데이터 탐색시엔 위치를 알면 빠르게 탐색가능

연결리스트는 데이터 삽입삭제는 효율적이다
포인터로 연결만해주면된다
데이터 탐색시엔 비효율적이다
노드가 파편화 되어있기때문에 느림

원형큐?!
순차자료구조를 사용할땐 원형큐를 많이 사용
back과 front가 같은위치에서 시작
데이터 입력시 back이 한칸 움직임
pop시 front가 back위치로 움직임
끝에 다다를시 처음위치로 감

6/27================================
검색할범위를 절반으로 불여가며 검색
사용에 있어서 두가지조건
정렬되어있어야한다.
임의접근이 가능한 선형리스트여야한다.
범위는 기본적으로 [s, e)로 표현한다. 구현에따라 [s, e]로도 가능
				<이진검색구현>
bool BinarySearch(int* arr, int size, int value)
{
    // 범위는 [s, e)로 표현한다. 구현에 따라 다르게 할 수 있다.
    int s = 0, e = size;
    while (s < e)
    {
        int m = (s + e) / 2;
        // 오버플로우를 방지하기 위해 아래처럼도 사용할 수 있다.
        // int m = s + (e - s) / 2;
 
        // 찾았다면 true다.
        if (arr[m] == value)
            return true;
        // 배열이 정렬되어 있기 때문에
        // 중간값과 비교하여 범위를 조정한다.
        else if (arr[m] < value)
            s = m + 1; // 크다면 시작위치를 중간보다 하나크게잡는다
        else
            e = m; // 작다면 끝범위를 중간으로 둔다
    }
 
    return false;
}
이진검색 시간복잡도 : O(logN)

pair원소를 두가지(first, second)를 갖는다
범위[first, second)를 반환
기본적으로 비교연산자도 제공하므로 쓸 상황이 많음

그래프
관계에 특화된 자료구조. 정점(vertex) 간선(edge)으로 구성
정점 - 고유하게 식별되는 객체
간선 - 정점간의 관계
방향그래프와 무방향그래프로 구분
간선이 단순연결이상의 정보를 가지는 가중치그래프(=network)도 있다

관계는 추상적인의미를 가지기때문에 프로그램에 따라서 성격이 바뀌기에 일반적으로 사용하기어렵다. 그래서 언어로서 그래프를 제공하지않는다.

정점에부속되엉ㅆ는 간선의 수를 차수
정점으로 들어오는 방향 - 진입차수
나가는 방향 - 진출차수

한정점에서 다른정점으로 연결된정점을 순서대로 나열한 리스트를 경로라한다.
간선수를 경로길이
모두 다른 정점으로 구성된 경로 - 단순경로
단순경로중 시작, 마지막정점이 같은경로 - 사이클
경로가 있으면 연결(connected)라 한다.
(모든정점이 연결 - 연결그래프, 아니면 단절그래프)

그래프표현법
인접행렬, 인접리스트

인접행렬
	정점이N개시 N x N크기의 2차원배열로 그래프 표현
	배열의 원소는 간선의 가중치나타냄
	그래프에 간선이 적다면 그만큼 메모리 낭비(희소그래프. 반대는 밀집그래프)
	연결시 true, 비연결시 false
	장점: 구현이 편하다.
	단점: 때에 따라서 간선의갯수가 작은경우엔 메모리낭비가 심하다
	
인접리스트
	각정점에 연결된 정점의 id만 저장하는 방식
	진출하는 간선만 표현한것
	장점: 필요한만큼만 메모리사용가능
	단점: 구현난이도 급상승
	
관계를 정의하고, 그래프를 구성한다.
데이터가저장되는 방식을 알고있어야한다.
각각의 장단점을 알고있어야한다.

무뱡향그래프는 양뱡향을 가진다.

그래프를 이용한 알고리즘
순회
	한 정점에서 시작해 그래프에 있는 모든 정점을 한번씩방문
	깊이우선탐색(DFS), 너비우선탐색(BFS)
	
	깊이우선탐색 - 시작정점의 한방향으로 갈수있는경로 최대로 갔다가, 갈곳이없으면 마지막 갈림길로 돌아와 다른 방향의 간선으로 탐색 스택사용
	
	너비우선탐색 - 시작정점의 인접한 정점을 모두 방문하고나서 다시 인접한정점을 차례로방문 큐를 사용한다.

그래프순회알고리즘 단계	
	1. 방문여부를 저장할 변수생성 -> 재방문방지
	2. dfs라면 스택, bfs라면 큐생성 -> 스택이나 큐에 저장되는 데이터는 다음에 방문할 정점
	3. 더이상 방문할 정점이 없을때까지 방문한다.
	
6/28=================================================

이진검색은 정렬된 선형리스트에서만

선형리스트
	insert함수는 pos위치에 데이터를 삽입
	
스택
	리스트의 일종으로 연산이 한 쪽 끝에서만 이뤄지는 자료구조
	컨테이너 어댑터인 스택엔 반복자가없다 => 순회용도x
	
큐
	선입선출
	삽입부분을 뒤, 삭제가 일어나는부분을 앞(front)이라한다.
	
덱
	양방향 데이터 삽입삭제 가능한 자료구조
	선형리스트와 연결리스트를 조합한 청크리스트(?)
	
그래프
	비선형적, 관계 특화 자료구조
	정점(vertex), 간선(edge)구성됨
	정점 - 고유하게 식별되는 객체(노드)
	간선 - 정점간의 관계
	방향성여부에 따라 방향그래프, 무방향그래프로 구분함
	간선이 단순연결이상의 정보를 가지는걸 가중치그래프라한다.
	인접
	부속
	차수
		진입차수
		진출차수
	경로
		단순경로
		사이클
	경로길이
	연결(connected)
	인접행렬
		정점x정점 크기의 2차원배열로 그래프 표현
		배열의 원소는 간선의 가중치
		희소그래프
		밀집그래프
	인접리스트
	순회
		DFS
		BFS
	
	최단경로
		가중치 그래프에서 두 정점을 연결하는 경로중 가중치의 합이 최소인 경로
		간선이 없다면 무한대값으로 저장, 가중치는 음수여선 안된다.
		다익스트라 알고리즘(암기)
			하나의 시작 정점에서 다른 정점까지의 최단 경로를 구하는 알고리즘
			무방향, 방향 모두 적용가능
			게임 길찾기 알고리즘의 기본			
		A* 알고리즘
		플로이드 알고리즘
			모든 정점사이의 최단경로를 구하는 알고리즘
			
6/29=========================

트리
	그래프의 일종으로 계층형자료구조
	방향이있다.
	사이클(처음에서 끝으로 돌아오는것)이 없다.
	정점을 노드라고 표현한다
	stl에서 함수를 제공해준다.(set, map, multiset, multimap)
	트리의 시작노드 - 루트노드
	관계는 부모-자식관계
	재귀적인 구조를 가진다(트리아래에는 또다른 트리가 있기에 이를 서브트리 라고한다)
	형제관계노드 - siblings 노드
	트리에는 레벨이 존재하고 루트노드는 레벨0이다. 내려갈수록 레벨 증가
	레벨은 높이로 표현할수있다.
	데이터베이스 저장형태는 트리형태
	B트리는 트리의 차수가 2
	폴더저장이 트리임	
	
	조상노드 - 한 노드에서 간선을 따라 루트노드까지 이르는 경로에 있는 모든 노드
	자손노드
	차수
	내부노드 - 단ㄴ말노드를 제외한 나머지 노드
	포레스트 - 트리의 집합
	
	순회
	트리에선 루트시작으로 왼쪽먼저간다음 끝나면 자신으로 돌아와서 오른쪽으로간다
	전/중/후 자기자신을 몇번째로 방문하는냐에 따라 나눔
		전위순회 - 본인을 가장 먼저 방문 본인 왼 오 A B D H I E J C F G (깊이우선탐색과 동일)
		중위순회 - 자신을 중간(두번째)으로 방문 왼 본인 오 H D I B J E A F C G
		후위순회 - 자신을 마지막으로 방문 왼 오 본인 H I D J E B F G C A
		레벨순회 - 레벨순으로 A B C D E F G H I J (너비우선탐색과 동일)
		
	이진검색트리
	binary search tree는 필수적으로 알아야한다.
	한 노드 기준 왼쪽 서브트리는 본인보다 작은값, 오른쪽 서브트리는 자신보다 큰값을 가지고 있는 트리를 이진검색트리라한다
	트리의 차수가 2이하인 트리
	왼쪽자식의 노드의값 <= 부모노드값 <= 오른쪽자식노드의값
	stl에구현된 트리 컨테이너는 모두 이진검색트리
	
	트리의 형태에 따라 시간복잡도 다름
	균형잡히면 OlogN 편향시 ON에 가까움
	편향-노드가 한쪽으로만 삽입
	
	이진트리 중위순회시 작은값부터 큰값이 나옴 <- 이진검색
	데이터 삽입순서에 따라 효율이 천차만별이다
	데이터를 어떻게 넣든간에 자기가혼자 균형을 맞춤 - AVL트리(자가균형트리)
	다른 자가균형트리로는 레드블랙트리가 있다.
	stl에 있는 트리는 레드블랙트리임
	삽입 삭제 검색 모두 O(logN)
	
그래프에서 가중치가 동일한경우 bfs경우 인접한노드에서 차례대로 검색하기에 최단경로를 찾아낼수 있다.

인접행렬 graph[i][j] i에서 j로 가는 간선이 있다면 1, 없으면 0 

6/30====================================
queue에 다음 탐색정점을 넣으면서 한단계 level들을 동시에 순환
물결처럼 퍼져나간다.
S->E
10110	 10110	  10110    10110    10110    101S0    10SS0    10SS0
10010	 10010	  10010    10010    100S0    100S0    100S0    S00S0
11110 -> 11110 -> 11110 -> 111S0 -> 11SS0 -> 1SSS0 -> SSSS0 -> SSSS0
01010	 01010	  010S0	   010S0	010S0	 010S0	  0S0S0	   0S0S0
E101S	 E10SS	  E10SS    E10SS    E10SS    E10SS    E10SS    ES0SS

90760
80050
76540 -> S에서 E까지 가는 최단경로는 9 (처음을 1로)
07030
E802S

최단경로 : bfs, 다익스트라
	가중치가 없는 그래프에서 최단거리를 알아내는 알고리즘 : bfs
	
	
7/1================================================
해가있는트리를 상태공간트리라고한다.
숨바꼭질문제는 상태공간트리를 순회해서 답을 찾는문제다.
(모든 경우의수를 그려놓은것)

집합
유일한 데이터만을 가지는(저장하는) 자료구조

집합에서 insert는 타입이 pair다. 즉, 두가지의 타입을 반환하고있다.
bool타입이 들어있는경우는 정상삽입시 true 아니면 false

이진검색트리 - 왼쪽 서브트리는 본인보다 작은 값, 오른쪽 서브트리는 큰 값.
삭제시 중간값을 넣어줘야 균형이 깨지지않음

7/3===========================================================
dfs: stack, 재귀
bfs: queue

재귀 노드에 방문하면 데이텉출력
자식들을 순서대로 재귀호출 자식들이 호출을받으면 마찬가지로 자기를출력하고 자식들을 재귀호출 자식들을 먼저호출하기에 dfs가능
자신을 출력하고 자식을 호출 반복
재귀호출은 정방향 호출

브루트포스(완전탐색 알고리즘)


