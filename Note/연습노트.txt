정렬의 종류 - 버블정렬, 삽입정렬, 힙정렬, 퀵정렬

	삽입정렬
	 - 첫시작은 배열의 두번째 원소부터 시작
	 - 선택된 원소보다 앞의 원소들은 이미 정렬된 상태(쓸모없는 비교를 줄이기때문에 버블정렬 보다 빠름)
	 
증감연산자가 참조 연산자보다 우선순위가 높다

포인터를 배열처럼 사용 *(arr + i) == arr[i]
포인터의 이름은 배열의 첫번째원소의 주소를 가리키므로,
i x 자료형의 크기만큼 더해지면 결국 배열 i와 같게됨

구조체 
 - 다른 타입을 가진 여러개의 변수를 묶어 사용자가 직접 자료형으로 만들어 사용, 관리
 - main함수 전에 선언하며 main함수 안에 선언시 그 함수 내에서만 사용가능하다.
 struct 구조체 이름 { 구조체 멤버들 };
 typedef선언하면 함수내에서 구조체를 사용할때마다 struct를 써줄 필요가없음
 구조체 포인터 사용예시
	(*ptr).age || ptr->age
 자기참조구조체?
	자기자신을 가리키는 포인터를 멤버로 가질수있음
	연결리스트와 트리에서 사용된다
 구조체를 인자로 전달할때는 보통 포인터를 많이 쓴다. 왜냐하면 구조체를 그냥 넘겨주게되면
 구조체 크기만큼 복사할 공간이 더 필요하게 되어 비효율적이다.
 따라서 복사할필요가 없는 포인터를 이용해 구조체를 매개변수로 전달한다.(값을 변경할필요가없을때도)
 
 malloc은 어디에 할당?
	메모리의 힙 부분은 사용자가 자유롭게 할당, 해제가능
	따라서 malloc함수도 힙을 이용한다.
c++에서도 malloc을 쓰지만 new와 delete도 새로 지원한다.
new는 malloc과 대응, delete는 free와 대응
new쓰는 방법은
	Type* pointer = new Type;  <= 이렇게 쓴다
	*pointer = 값;
	그리고
	delete pointer; 이렇게 해제가능
배열 할당 new[] - delete[]

구조체 자체에 함수를 만들어, 각 구조체 변수가 각각 자신의 함수를 가지게 됨(이거 클래스 얘기?)
객체란 변수들과 참고자료들로 이루어진 덩어리다.(animal이란 객체는 자신의 상태를 알려주는 변수와 자신이하는행동들을 수행하는 함수(method)들로 이루어짐)
외부에서 어떠한 객체의 인스턴스 변수의 값을 바꾸지 못하며 오직 객체의 인스턴스 함수를 통해서만 가능하다
캡슐화 : 외부에서 직접 인스턴스 변수의 값을 바꿀수없고 항상 인스턴스 메소드를 통해서만 간접적으로 조절
캡슐화의 장점 - 객체가 내부적으로 어떻게 작동하는지 몰라도 사용가능하다
클래스는 객체의 설계도(blue print)라고 볼수있다
클래스를 이용해서 만들어진 객체를 인스턴스라 부른다.
함수의 이름이 같더라도 인자가다르면 다른 함수 <= 함수의 오버로딩

함수오버로딩과정
	1단계 : 타입이 정확히 일치하는 함수찾음
	2단계 : 일치하는 타입이 없을시 형변환을 통해 찾음
			(char, unsigned char, short => int)
			(unsigned short => int || unsigned int (int 크기에 따라))
			(float => double)
			(enum => int)
	3단계 : 그래도없으면 포괄적인 형변환을 통해 찾음
			(numeric타입은 다른 숫자타입으로)
			(enum도 임의의 숫자타입으로)
			(0은 포인터타입 || 숫자타입으로)
			(포인터는 void포인터로)
	4단계 : 유저ㅓ정의된 타입변환으로 찾음
	
생성후 초기화를 도와주는 생성자
"객체 생성시 자동으로 호출되는 함수" 생성자 
객체를 초기화 하는 역할이기에 리턴값없음

생성자모양
	클래스이름 (인자) {}
	Date(int year, int month, int day)
	{
		year_ = year;
		month_ = month;
		day_ = day;
	}

함수호출하듯이 사용하는걸 암시적방법
	Date day(2011, 3, 1); implicit 암시적
생성자를 호출한다는것을 보여주는 것이 명시적방법
	Date day = Date(2012, 3, 1); 명시적 explicit

생성자를 정의하지 않았을땐 어떤 생성자가 호출?
-> 디폴트 생성자
디폴트생성자는 인자를 하나도 가지지 않는 생성자
클래스에서 사용자가 어떠한 생성자도 명시적으로 정의하지 않았을경우 컴파일러가 자동으로 추가
인자가없는 기본생성자를 호출하기 위해선 A a; 형태를 써야한다
A a();처럼 하면 A를 리턴하는 함수 a 즉, 함수를 정의한것이된다.
암시적표현으로 객체를 선언할때 반드시 주의해두어야할사항
명시적으로 디폴트생성자를 사용할수있다
	Test() = default; // 디폴트생성자 정의
생성자도 함수이므로 오버로딩가능

기본메소드
	기본생성자, 소멸자, 이동생성자, 이동할당연산자, 복사생성자, 복사할당연산자

레퍼런스는 메모리상에 존재하지않을수도있다? 이뭔양자ㅏ역학도아니고
참조는 존재하나 메모리상에선 존재할수도있고 존재하지않을수도 있다 ㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋ

클래스 멤버의 구성요소들
- 멤버변수
- 멤버메소드
- 내부타입(클래스안에 다른클래스, 열거형, 혹은 타입별칭재정의)
- 멤버템플릿

선언은 컴파일러에 식별자를 알려주는것
정의는 식별자에 정보를 제공하여 메모리가 할당되는것
가장큰차이는 메모리 할당여부
할당은 메모리에 데이터를 저장하는것
정의하면서 값을넣어주는것을 초기화라고한다.

------------------------------------------------

SOLID원칙은 클린 아키텍쳐에서 소개된 설계바탕 5원칙

SRP 단일책임원칙
객체는 한가지의 기능만을 가지며 관련없는 기능은 합치지않음
	기존코드는 병경하지않으면서 기능은 추가가능한 설계
	모듈은 변경의 이유가 하나 예를들어 이미지 기능은 이미지만 하게끔

개방폐쇄법칙 OCP
확장은 개방적, 수정은 폐쇄적
객체는 확장하는데 열려있고, 수정에는 닫혀있어야한다는 원칙으로
기존 코드를 수정하기보단 새로운코드를 추가하는 방식으로 시스템 행위변경이 가능하도록 설계해야 쉽게 변경이 가능하다. 캡슐화와 관련이 깊다

리스코프 치환원칙 LSP
상위타입의 객체를 사용하다 하위타입객체를 사용해도 정상작동해야된다.
즉 부모클래스에서 동작하는 기능은 자식클래스에서 확장은 될지언정 틀리게 동작해선 안된다.

인터페이스 분리원칙 ISP
범용의 인터페이스를 만드는것이 아닌 클라이언트에 특화된  인터페이스사용
즉 필요한 인터페이스만 분리해서 설계하는 원칙이다
클라이언트는 사용하지않는 메소들에 의존하게해선안된다
큰 인터페이스들을 작은단위로 나누는것이좋다
예를 들면 수륙양용차를 인터페이스화 시키면 지상에서 운전, 물위에서 운전하는 기능을 가지게되고 
이를 일반 차량에 적용시킬시 물위에서 운전하는 기능은 쓰지않지만 포함되게된다.
따라서 수륙양용차를 만들기위해선 차량인터페이스, 보트 인터페이스를 구상한뒤
두개를 합치는 방향으로 설계하는것이좋다.

의존성 역전원칙 DIP(Dependency Inversion Principle)
고수준묘듈은 저수준묘듈의 구현에 의존해선안된다.
추상화 모듈을 만들어서 고수준모듈, 저수준모듈이 추상화클래스에 의존하게 만들어서 유지관리쉽게 하는것이다. 즉, 고수준모듈이 저수준모듈에 직접적인 의존성을 가지않는것이 가능하다.
예를들어 동물원에 개와, 고양이가 있으면 동물원은 고수준모듈로 볼수있고, 개와 고양이는 저수준 모듈로 볼수있다.
동물원은 개와 고양이에 의존성을 띄게된다 고수준이 저수준을 포함하는게 직관적이고 당연시하다
여기에 양과 소를 추가하게 되면 동물원은 의존해야하는 코드가 많아지고 나중에 이를 수정할땐 불편하게 된다.
이를 위해서 의존성역전원칙을 사용한다.
동물이라는 추상화클래스를 만든뒤 동물원이 동물에 의존하게 만들고 개와 고양이가 동물에 의존하게 만들면 나중에 양과 소가 추가된다 하더라도 동물원은 직접적으로 수정할 필요가없어진다.

책임주도설계?
협력
	책임을 가진 객체는 각자의 역할을 가지게되고 각자의 역할을 수행하는 협력관계를 가지게 된다.
객체
	상태(필드)와 행동(메소드)을 함께 지닌것
	객체는 충분히 협력적이어야한다. 다른객체에 요청하고 다른 객체의 요청을 잘 처리해야한다.
	객체는 자율적이어야한다. 객체의 요청에 응답하는 방식은 객체 스스로 판단하고 결정한다.
	서로다른 방식으로 응답할수있는능력을 다형성이라한다.
책임
	요청을 처리하기 위해 객체가 수행하는 행동을 가진것(객체의 역할)
메세지
	객체지향의 세계에선 오직 한가지의사소통수단만이 존재하는데 이를 메시지라한다.
	메시지를 전송하는 객체를 송신자, 받는 객체를 수신자라한다.
	객체가 수신된 메시지를 처리하는 방법을 메소드라한다.
	
협력
	각자의 역할을 지닌 객체가 서로 협력하면서 자신이할수없는 일을 할수있도록 적절한 역할을 가진 객체와 상호작용하는것
객체
	객체는 협력적이어야한다. 타 객체의 요청을 처리, 다른 객체에 도움을 요청하면서 동일한 목적을 달성
	객체는 자율적이어야한다. 다른 객체와 협력하도록 개방적이어야함과 동시에 내부 동작에 접근하지 않고 자율적으로 처리할수있어야한다.
	
이런 행동을 경계로 캡슐화하면 객체의 자율성이 높아진다. 자율성이 높아지면 객체의 지능이 높아진다. 협력하는 객체 지능이 높아지면 과정은 유연하고 간결해진다.
	
역할
	여러객체가 동일한역할수행
	역할은 대체가능성을 의미
	각 객체는 책임 수행 방법을 자율적으로 선택가능
	하나의 객체가 동시에 여러 역할 수행가능
	
책임
	객체가 수행하는 행동을 책임이라한다.
	무엇을해야 하는지 설정하고 구체적이여도안되며 추상적이어도안된다
	객체는 SRP원칙으로 하나의 책임을 가진다.

--------------------------------
	
2p
	이번 발표를 통해 객체지향 프로그래밍의 필요성, 주요 개념 그리고 설계5원칙 solid에 대해서 알아보도록 하겠습니다.
3p
	먼저 객체지향 프로그래밍의 필요성을 한번 생각해봤습니다.
	객체지향프로그래밍이란 객체를 중심으로 프로그래밍하는것을 말합니다. 
	이는 기존 c에서 쓰던 절차적 프로그래밍에서 부족한점을 보완하고 한계를 극복하기위해 생겨났다고 볼수있겠습니다. 
	그렇다면 절차지향의 한계점이 무엇인지 간단히 알아보도록 하겠습니다.
4p
	절차지향에선 데이터와 데이터를 다루는 함수를 분리시켜놓았습니다.
	c언어의 데이터를 처리하기위해 데이터 의존적 함수를 만들어 호출합니다. 모든 프로세스가 데이터에 의존적이게 되고 이는 데이터와 데이터를 처리하는 로직이 분리되어있어 코드가 길어지게됩니다. 또 데이터를 받기위해 주소값을 사용함으로서 함수를 다루는데있어 불편함을 겪을수있습니다.
	
5p
	두번째론 함수의 이름을 항상 다르게 작성해야하는 불편함입니다.
	같은 기능을하는 함수를 작성하더라도 반환되는 타입이 다르다면 매번 함수이름으 다르게 작성하는 시간 낭비를 할 수 밖에없습니다.
	
6p
	세번째, 확장하기 불편하다.
	대부분의 코드가 프로그램 동작순서와 동일하게 개발되었으므로 코드간의 결합도가 높기에 나중에 코드의 수정이 필요하게된다면, 해당 코드와 연관된 모든 코드를 수정해야함으로 확장 및 유지보수하기가 매우 어렵습니다.
7p
	이제 객체지향에 대해 알아보겠습니다.
	먼저 객체지향의 주요개념부터 간단하게 설명하겠습니다.
	객체지향엔 캡슐화, 상속, 추상화, 다형성이 존재합니다.
8p
	캡슐화란 데이터와 데이터를 다루는 함수를 하나의 단위로 묶은것을 의미합니다.
	같은 단위로 묶게되면 데이터관리가 용이하고 이용이 편해지는 장점을 가집니다.
	그리고 객체가 구현된 방식의 세부정보를 은닉하면서 사용할수있습니다
	은닉된 데이터에 실수로 접근해 잘못바꾸는것을 방지할수있습니다.
9p
	상속이란 부모클래스멤버를 재사용해 자식클래스에서도 사용할수있는걸 말합니다.
	코드의 재사용이 가능하므로 시간을 절약할수있습니다.
10p
	추상화란 클래스가 구현해야할 기능만을 명시한 것입니다.
	즉 구현정보를 숨기고 인터페이스화 시켜 쉽게 사용하게끔 하는것입니다.
	예를 들면 자동차를 추상화하면 운전대, 페달, 변속기가 존재하고 모든 차량은 내부적으로 조금다르게 작동하지만
	우리는 대부분의 차량을 운전할수있습니다. 이것이 추상화를 쓰는 이유가 되겠습니다.
11p
	다형성이란 여러가지 형태를 가지는걸 의미합니다.
	인터페이스를 유지한채로 구현세부사항을 바꿀수 있으며 이는 가상함수를 통해 이루어집니다.
	이런 변경을 오버라이딩이라고 합니다.
12p
	다음으로 객체지향 설계중 책임주도설계를 간단하게 설명하겠습니다
13p
	협력, 객체는 각자의 역할이 주어지는데 자신이 못하는 일을 다른 객체와 상호작용을 통해 전체적인 프로그램을 구성할수있습니다.
14p
	객체는 상태와 행위로 이루어져있습니다.
	그리고 객체는 협력, 자율성이 있어야합니다.
15p
	객체가 수행하는 행동을 책임이라고합니다.
	책임을 얼마나 적절한 객체에 할당하느냐에 따라 설계품질을 결정할수있습니다.
16p
	메시지는 객체간 의사소통 수단입니다.
	객체를 이용해 코드호출하는걸 메세지 보낸다로 말할수있고
	그 메세지를 처리하는 방법이 메소드라 할수있습니다.
17p
	마지막으로 객체지향 5대원칙인 SOLID에 대해 알아보겠습니다.
18p
	단일책임원칙은 객체는 한가지 기능만을 해야한다입니다.
	만일 한 클래스당 수행하는 책임이 많아진다면 유지보수하기 어렵다.
19p
	개방폐쇄법칙은 기존코드변경없이 기능을 추가할수있도록 설계해야한다는 법칙입니다.
	확장성이 높은 코드는 나중에 수정, 추가 및 유지보수하기 편합니다.
	이는 캡슐화와 관련이 깊은 원칙입니다.
20p
	리스코프치환원칙은 상위타입의 객체를 사용하다 하위타입객체를 사용해도 정상작동할수있어야하는 원칙입니다.
	상속과 연관있으며 부모클래스에서 동작하는 기능은 자식클래스에서 확장은 될지언정 틀리게 동작해선 안됩니다.
21p
	인터페이스 분리원칙입니다.
	큰 인터페이스를 작은 인터페이스로 분리하고
	필요한 인터페이스만 사용하게끔 설계하는 원칙입니다.
23p
	의존성역전원칙입니다.
	추상화 모듈을 만들어서 고수준모듈, 저수준모듈이 추상화클래스에 의존하게 만들어서 유지관리를 쉽게 하는것입니다.
24p
	이처럼 공격스킬이라는 추상화클래스를 추가해 모듈사이를 구분지어야 확장성을 높일수있습니다.
	
--------------------------------
C++ 스타일 함수
오버로드 - 다중정의가능하다
오버라이딩 - ?!

동적할당
	동적할당 : 프로그램 실행중에 변수를 메모리에 할당
	

-----------------------------
함수 기본인자

템플릿 : 일반화 프로그래밍을 지원하는 기능.
일반화 프로그래밍?
- 타입에 관계없이 알고리즘 기술

void Swap(int a, int b) // 인자끼리 서로값 바꿈
void Swap(double a, double b) 
void Swap(float a, float b) 

c++에선 템플릿 c#에선 제네릭

클래스템플릿, 함수템플릿으로 나눔
모던cpp로오면서 다양한 템플릿 지원 일단넘어감

기본구조
template <parameter-list> declaration

함수템플릿의 경우 <>생략가능

타입을 인자처럼 전달할수있다

타입파라미터는 타입을 받을 수 있다.

template <typename T = int> class C {}; //기본인자 전달도 가능하다. 
C<> c; c는 C<int> 타입이다

비타입파라미터는 구체적인 타입을 지정

템플릿파라미터는 템플릿을 전달하고 자주 사용되진않는다. 템플릿파라미터도 타입파라미터로 받을수있고 이를 사용하는 경우는 제약을 걸어둘때다

특수화
"컴파일타임"에 일어남
컴파일러가 템플릿을 기반으로 특정타입을 생성

"템플릿은 헤더파일에 모든내용적음" 정의를 소스파일에 나눠적으면 링크오류발생

빌드타임때문에 헤더에다 넣지 않는다
파일간의 종속성이 생기면?

A.h
A만 수정해도 내용을 포함한 모든 파일을 재컴파일한다 -> 빌드시간 증가

temp.cpp -> A.h 
A를 포함했다는 이유로 재컴파일된 temp

되도록 빌드시간을 줄이기위해 전방선언? 등 여러노력해야한다

템플릿의 경우엔 헤더파일의 모든 내용기록해야함

#include "Temp.h"

int main()
{
	A<int> a; //오류없음
	A<float> b; // int일경우 T부분을 int로바꾸고 이처럼 float을 추가한경우
	// 템플을 복사해 float으로 바꿔서 가져다 사용한다.

	//a.SetData(10); //확인안되는 외부기호 오류 -> 어딨는지 못찾겠다 오류
	// 따라서 헤더파일에 전부 적어줘야한다 cpp에 따로 써놔도 못찾음


	// 컴파일오류(문법오류)
	// 링크오류(linkage 실패, 코드와 메모리연결 실패)
}
//// 명시적, 부분 특수화
//#include <iostream>
//
//template <typename T1, typename T2>
//void Print(const T1& a, const T2& b)
//{
//	std::cout << a << '\n';
//	std::cout << b << '\n';
//}
//
//// 명시적 특수화
//template <>
//void Print(const int& a, const double& b)
//{
//	std::cout << "이것은 명시적으로 특수화 되었습니다.\n";
//}
//
//// 부분 특수화
//template <typename T>
//void Print(const T& a, const int& b)
//{
//	std::cout << "이것은 부분적으로 특수화 되었습니다.\n";
//}
//
//double d = 1.0;
//Print(d, d); // Print<double, double>; 암시적 특수화 버전 호출
//
//int i = 1;
//Print(i, d); // Print<int, double>; 명시적 특수화 버전 호출
//
//Print(d, i); // Print<double, int>; 부분 특수화 버전 호출

-----------------------------------
자료구조
	선형구조, 비선형구조로 나뉜다
	선형은 일렬이다
	선형인 리스트 스택 큐
	비선형엔 그래프 트리

	4가지연산
	- 읽기, 검색, 삽입, 삭제

	자료구조 구현방법
	순차자료구조
		배열을 이용한다(연속성)
		임의원소 즉각접근가능
		캐시지역성 효과로 순회빠름
			(지역성 : cpu가 특정부분에 위치한 데이터나 코드를 집중적으로 접근)
		데이터크기만큼 메모리저장

	연결자료구조
		포인터를 이용한다(연결성)
		선형시간복잡도를 가짐, 느린편(노드들이 흩어져있음)
		순회 느림
		포인터저장을위해 여분의 메모리 사용함

	알고리즘분석
		알고리즘의 자원사용량을 분석하는것이다 자원을 적게사용할수록 효율적(자원 : 실행시간, 공간등을 말함)
		시간복잡도(시간), 공간복잡도(메모리) 개념사용

	시간복잡도
	단순측정으로는 실행시간분석불가(하드, 소프트웨어 환경에따라 다름)
	하드웨어 소프트웨어 환경을 배재한 객관적인 지표 - 시간복잡도 
	연산이 몇번있는지 알수있다

	입력값이 커질수록 차이가 커진다 이를 실행시간 성장률이라한다

	다항식의 시간복잡도에서 시간이지날수록 결과값에 관여정도가 차이가난다

	가장기여도가 큰항만 남기고 표기하는방법 -> 점근적표기법
	그중 big-o표기법많이 사용하고 이것은 점근적 상한선을 제공한다

	O(1) < O(logn) < O(n) < O(nlogn) < O(n2) < O(n3) < O(2n) < O(n!)
	항상 카테고리 별로 순서가 지켜지진 않는다 그래프를 그려서 교차점을 비교하고 그 이전에선 속도가 반전될수있다.

	그리고 빅오표기법은 정확하지않다 그냥 한눈에 빨리 파악을위해쓴다(대략적인 지표만 제공)
	한 알고리즘이 다른 알고리즘보다 실제로 빠르더라 하더라도 같은 방식ㄷ으로 표현될수있다
		ex) 2n + 1
			2n + 4 둘다 O(n) 이다

	항상빠르냐? 언제를 기준으로 빠르냐? -> 시간복잡도 그래프를 기점으로 설명

	공간복잡도
		메모리관련

	시간과 공간은 반비례적이다 대부분 시간을 위주로 판단한다 시간자원이 더 귀중하므로

	STL?
	표준템플릿라이브러리 standard template library
	
	컨테이너 라이브러리 - 임의타입객체보관할수있는 자료구조 구현체
	반복자 라이브러리 - 컨테이너에 보관된 원소에접근 할수있는 포인터
	알고리즘 라이브러리 - 반복자를 가지고 일련의 작업수행

	컨테이너는 구현체, 반복자는 접근할수있는 포인터
	구현코드를 줄이기위해 나눔
	반복자를 컨테이너와 알고리즘구현 사이에 넣어 각요소에 추상적으로 접근가능
	N * M을 N + M으로 줄일수있다

	리스트
	순서를 갖고있는 자료구조

	선형리스트(순차)
	array, vector로 구현되있다 임의접근가능함
	정적배열, 동적벡터
	읽기 - O(1)의 시간
	검색 - 하나하나 비교시 O(n), 정렬되있음 이진검색사용 O(log n)
	삽입 - 어디에 삽입하냐에따라 시간다름 맨끝 O(1). 처음, 중간시 O(n)걸림
	삭제 - 어디에서 삭제하냐에 따라 시간다름
			맨끝 O(1), 처음 중간시 O(n)걸림
			
#############################################################
		
# 자료구조 및 알고리즘
- STL : 표준 템플릿 라이브러리.
    - 컨테이너 : 자료구조 구현체
    - 반복자 : 컨테이너의 요소에 접근할 수 있는 포인터
    - 알고리즘 : 반복자를 기반으로 수행되는 절차
- 리스트 : 순서가 있는 자료구조
    - 선형 리스트 / 단일 연결 리스트, 이중 연결 리스트, 원형 연결 리스트
    - 선형 리스트
        - 임의 접근이 가능하다.
        - 읽기 : O(1) / 삽입, 삭제 : 맨 끝이면 O(1), 처음이나 중간이면 O(N) / 검색 : O(N), 정렬되어 있을 시 이진 검색을 사용해서 O(logN)

#############################################################

class A { T Data; }; 는 클래스 내부를 다르게 쓰는 것이니(사실상 인자가 달라지는 느낌이긴 하지만) 오버라이딩

Swap(T& lhs, T& rhs) / 는 매개변수의 목록이 달라지는 것이니 오버로딩

####################################################################

명시적으로 타입을 줘야하기 때문에 템플릿으로 써야하는게 아니라
템플릿을 사용하면 어떤 자료형이든 다 섞어서 쓸 수 있는데 그 중에서 거르고 싶은게 있다면 명시적으로 선언해서 빼는 것 같아요

##############################################

템플릿을 사용할때 주의할 점이 있는데 헤더 파일에서 선언을하고 소스파일에서 정의를 하면 컴파일시 헤더파일을 복사한후 템플릿부분을 교체하는데(클릭) 정의부분을 찾을 수 없게 되어 링크 오류가 발생한다.

#############################################################################

std::array에 대해 아라보자~

고정된 크기의 배열을 담고있는 컨테이너임
(고정? 정적이란말인가?)

C언어 배열인 T[N]과 비슷하게 작동함 {}를 통해 초기화가능
(예시. std::array<int, 3> a = {1, 2, 3})
다만 C배열과 다르게 배열이름이 T*로 자동 형변환 안된다고함
(으음?)

std::array를 통해 배열형태를 유지하면서 반복자, 대입연산자 사용가능
(알고리즘에 정의된 함수들을 std::array에도 사용할수있다~)

참고로 크기가0인 std::array는, array.begin() == array.end()

반복자 무효화
std::array의 반복자는 배열객체(?)가 살아있는 동안 절대 무효화(?)되지않는다
(뭔소리야?)
다만, swap후 기존의 반복자가 같은 위치를 계속 가리키고 있으므로 다른 값을 가리킬수있다
(뭔소리냐고;;)

Aggregate타입이기에 aggregate초기화 방식사용할수있다.
(처음 듣는 타입인데?)

배열소멸시 모든 원소들의 소멸자 호출한다.

대입연산자 사용가능하다
std::array<int, 3> a = {1, 2, 3};
std::array<int, 3> b;

b = a; b에 a의 배열이 들어간다

멤버접근함수
at, operator[]
front, back
data

반복자들
begin, cbegin
end, cend
rbegin, crbegin
rend, crend

크기관련
empty
size
max_size

여러가지작업관련
fill
swap

*vector 는 std::array와 다르게 데이터 컨테이너의 크기를 줄이거나 늘릴 수 있음

std::vector에대해 아라보자~

데이터 타입으로부터 자유로워지고싶다 -> 템플릿탄생배경
