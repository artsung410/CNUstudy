템플릿과 STL

템플릿
일반화 프로그래밍을 지원하는 기능.
일반화 프로그래밍?
- 타입에 관계없이 알고리즘 기술

클래스, 함수 템플릿으로 구분
(c++ 14부턴 별칭템플릿, 변수템플릿, 컨셉도 지원하지만 일단 다루지않음)

템플릿 기본구조
template <parameter-list> declaration

특수화
	템플릿에선 타입을 인자처럼 전달할수있다
	컴파일타임에서 일어남.
	컴파일러가 템플릿을 기반으로 특정 타입 생성
	
템플릿은 헤더파일에 모든내용적음.
	소스파일에 나눠적으면 링크오류발생
	
명시적특수화
	모든 템플릿 파라미터에대해 특수화

부분특수화
	일부 템플릿 파라미터에만 특수화

STL
c++에서 사용하는 표준템플릿라이브러리를 말한다.
컨테이너 라이브러리 - 임의타입 객체 보관할수있는 컨테이너 제공
	컨테이너 : 자료구조의 구조체
반복자 라이브러리 - 컨테이너에 보관된 원소에 접근할수있는 반복자 제공
	반복자 : 컨테이너 요소에 접근할수있는 포인터
알고리즘 라이브러리 - 반복자를 가지고 작업수행하는 알고리즘 제공
	알고리즘 : 문제해결을 위한 철차
	
반복자를 따로 구분한이유
-구현 코드 개수 줄이기위해

#########################################

3p	템플릿이란 c++에서 일반화 프로그래밍을 지원하는 기능으로
	이를 사용하면 클래스나 함수의 연산을 정의, 사용자가 작업해야하는 구체적인 형식을 지정할수있습니다.
	여기서 나온 일반화 프로그래밍은 타입관계없이 알고리즘을 기술하는 하나의 패러다임입니다.
	
4p	템플릿은 클래스템플릿과 함수템플릿으로 구분할수있습니다.
	클래스템플릿을 사용하면 타입에따라 다르게 동작하는 클래스를 만들수있습니다.
	함수템플릿또한 클래스템플릿과 비슷하게 동작하며 대상이 함수로 바뀐점만 다릅니다.
	둘다 원하는 매개변수의 타입을 지정할수있습니다.
	
5p	템플릿의 인스턴스화 예시를 나타냈습니다.
	클래스템플릿과 함수템플릿 둘다 타입을 꺽쇠로 묶어서 인스턴스화 시킬수있구요.
	함수템플릿에선 원한다면 꺽쇠를 생략해도 인스턴스화 가능합니다.
	그리고 각각 타입에 대해 처음으로 호출될때 컴파일러는 해당 타입의 인스턴스를 생성하게 됩니다.
	
6p	다음으로 템플릿 파라미터에 대해 설명하도록 하겠습니다.
	템플릿은 하나이상의 템플릿 파라미터와 함게 매개변수화 되고
	그 파라미터에는 3종류의 파라미터가 있습니다.
	타입 파라미터, 비타입 파라미터, 템플릿파라미터 이렇게 3종류가 있고 하나씩 알아보도록 하겠습니다.
	
7p	타입파라미터 입니다.
	일반적인 파리미터형태를 띄고 있습니다.
	여기서 살펴볼것이 타입네임대신에 클래스로 대체될수있다는점입니다.
	세번째를 보시면 타입네임t에 인트형으로 기본인자 전달이 가능하다는점을 확인할수있습니다.
	
8p	비타입파라미터 입니다.
	비타입파라미터는 구체적인 타입을 지정해 사용할수있습니다.
	넣을수있는 타입으론 정수형, 포인터, 레퍼런스 등이 있습니다.
	
9p	템플릿 파라미터는 말그대로 템플릿을 전달하는 파라미터입니다.
	예문과 같이 꺽쇠안에 또다른 타입 네임이 들어갈수있는걸 확인할 수 있습니다

10p	특수화입니다. 
	특수화는 컴파일타임에 일어나며 명시적 특수화 부분특수화가 있습니다.
	
11p 명시적 특수화입니다.
	모든 템플릿 파라미터에 대해 특수화를 진행한다고 생각하면 될것같습니다.
	예시에선 템플릿파라미터부분을 비워두고 함수 파라미터 타입을 그대로 사용한것을 볼수있습니다.
	### [교수님 질문 대비] ### 
현수님 의견 : 명시적 특수화를 쓰는 이유는, 템플릿을 사용하면 어떤 자료형이든 다 섞어서 쓸 수 있는데 그 중에서 거르고 싶은게 있다면 명시적으로 선언해서 빼서 사용할수있습니다. 쉽게말해서 사용자의 의도에 맞게 다른 기능을 구현하기 위해서 라고 생각?합니다?

12p	다음은 부분 특수화입니다.
	명시적특수화완 다르게 일부 템플릿파라미터만 특수화해서 매개변수를 받은걸 확인할수있습니다.
	이처럼 사용자의 의도에 맞게 다른 기능을 구현하기위해서 특수화를 사용한다고 생각합니다.

13p	이번엔 표준템플릿라이브러리에대해 알아보겠습니다.
	줄여서 stl은 편의성을위해 c++에서 제공하는 라이브러리입니다.
	여러구성요소가 있지만 여기선 3가지 정도만 알아보도록 하겠습니다.
	
14p	먼저 컨테이너 라이브러리입니다.
	컨테이너라이브러리는 임의타입의객체를 보관할수있는 컨테이너 즉, 자료구조의 구조체를 제공해주는 라이브러리입니다.
	
15p 다음으로 반복자 라이브러리입니다.
	반복자 제공 라이브러리로 반복자는 컨테이너 요소에 접근가능한 포인터입니다.
	포인터라 주소 연산도 가능하고 컨테이너 모든 원소를 순회하는게 가능합니다.

16p	알고리즘 라이브러립니다.
	검색이나 정렬 계산 조작등 다양한 목적을위한 함수를 제공하는 라이브러리입니다.
	이때 반복자를 가지고 작업을 수행합니다.
	
	간사합니다.
	
#########################################################################

int arr[5];
arr[0] = int
arr[1] = int

int arr2[4]	[5]
-> arr2[0] = int[5]
-> arr2 = int(*)[5]

따라서 int (*parr)[5]에 arr2 담기 가능.

데이터부분과 데이터를 보여주는 부분을 나눠서 생각해야 나중에 수정이 쉽다.

###################################################################

6월15일 보충반 시작 ~ 7월 30일 보충반 종료

###################################################################

상속개념
상위클래스의 속성과 행동을 물려받는다 ( 포유류 -> 인간 )

인간 is 포유류
but 포유류 is not 인간.

특징 - 하위클래스는 상위클래스엔 없는 속성과 행동이 있다.

다형성 개념
상위클래스에 공격한다는 함수를 가상함수로 정의하고 그 밑 하위클래스까지 내려가서 총, 칼, 창등 무기에 정의된 공격한다를 불러와 쓴다. 왜냐면 총, 칼, 창은 공격방법이 다르기 때문에
하위클래스에 세분화해놓는다.

인터페이스. 하위클래스를 제어하는 가상함수를 상위클래스에 정의해놓은것

생성자가 왜 생겼나?
현실세계 모든 객체는 두가지의행동을 기본으로 갖고있다. 태어난다, 죽는다.
이를 클래스에서 생성자, 소멸자로 표현한다.
그럼 왜 굳이 함수로 표현하는가?
기본값을 가지고 탄생하거나, 랜덤값을 가지고 탄생하는 경우가 있다. 예를들어, 고블린이 탄생할때 생성위치를 랜덤하게 생성할수있다.
생성자는 결국 그 객체가 태어나면서 가지는 값들을 넣어줄수있다.
소멸자는 반대로 소멸하면서 하는 행동을 지정할수있게한다.

복사생성자 - 기존에 있는 객체를 복사후 새로운 객체를 만들어낸다.
이 새로운 객체는 주소가 같다. <- 얕은복사 (a를 복사해 b를 만든뒤 b의 값을 바꾸면 a도 바뀐다.)
주소가 다를경우는 <- 깊은복사 (a를 복사해 b를 만든뒤 b의 값을 바꾸면 b만 바뀐다. a를 바꿔야 b가 바뀐다.)

전산에서의 모든데이터는 선형적이다..

