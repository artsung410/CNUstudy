자료구조
	- 데이터를 효율적으로 조직하는 방법
	- 데이터 조직법에 따라 성능차이가 많이난다
	- 연산
		- 읽기 / 검색 / 삭제 / 삽입
	- 선형자료구조
		- 리스트: 순서를 갖고있는 자료구조
			- 선형리스트
				- 임의접근가능 O(1)
				- 하나씩비교 O(n)
				- 정렬시 이진검색가능 O(logN)
				- 삽입/ 삭제: 맨끝 O(1), 그외 O(n) -> 모든데이터를 이동시켜야하기에
			- 연결리스트
				- 단일/이중/원형
				- 검색: O(n)
				- 읽기: O(n)
				- 삽입/삭제: 위치를 알면 O(1)
		- 스택: LIFO구조
		- 큐: FIFO구조
	- 비선형 자료구조
		- 그래프: 관계를 나타내는 자료구조
			- 순회: 한정점에서 그래프에 있는 다른 모든 정점을 방문
		- 트리(DAG): 그래프의 일종(방향이 있고, 사이클이 없는 그래프)
트리
	- 그래프의 일종으로 방향이 있지만 사이클이 없는 그래프를 말한다.
	- 계층을 레벨로 나타내는 계층형자료구조
	- 노드와 간선으로 구성
		> 노드엔 데이터가 들어있고 간선은 부모/자식 관계를 나타낸다
	용어
		- 루트노드: 트리의 시작지점
		- 부모노드, 자식노드
		- 단말노드(leaf node): 말단부 자식노드가 없는 노드들
		- 형제노드(Siblings): 같은 부모를 가지는 노드들
		- 차수: 한 노드가 가지는 서브 트리의 수. 노드의 차수중 최댓값을 트리의 차수라 한다.
		- 내부노드: 단말노드를 제외한 나머지 노드
		- 포레스트: 트리의 집합
		
	순회: 자기자신 방문순서로 나눔
		- 전위순회: 자기자신을 가장 먼저 방문 (나-왼-오)
			A-B-D-H-I-E-J-C-F-G (BFS와 동일)
			
		- 중위순회: 자기자신을 중간에 방문 (왼-나-오)
			H-D-I-B-J-E-A-F-C-G
			> 이진검색트리 중위순회시 정렬된 데이터를 얻을수있다.
			
		- 후위순회: 자기자신을 가장 마지막에 방문 (왼-오-나)
			H-I-D-J-E-B-F-G-C-A
			
		- 레벨순회: 같은레벨방문
			A-B-C-D-E-F-G-H-I-J
	
	이진검색트리
		- 트리의 차수가 2이하인 트리
		- 한 노드기준 왼쪽 서브트리는 부모노드보다 작은값, 오른쪽 서브트리는 큰값을 가짐
			( 왼쪽자식노드값 <= 부모노드의 값 <= 오른쪽자식노드값 )
		연산
			- 균형잡힌 트리의 모든 연산은 O(logN)이지만, 편향되었다면 O(N)에 가까워짐
				> 편향: 노드가 한쪽으로만 삽입
				> 균형: 왼,오 서브트리의 높이차가 1~2미만인경우
					- 자가균형트리: AVL트리, 레드블랙트리
					> 참고로 C++ 라이브러리에 구현된 트리는 레드블랙트리
	힙
		- 트리의 일종으로 완전이진트리에 있는 노드중 키값이 가장 큰 노드나, 작은 노드를 찾기 위해 만든 자료구조 (우선순위 큐)
			> 완전이진트리란?
		- 최대, 최소노드를 찾기 적합하다
		- 자주사용된다
		- 배열로 구현한다
		- C++의 경우 최대힙으로 구현
		- C#에선 최소힙으로 구현

		힙의불변성
			- 최대/최소원소에 즉각 접근가능. 최대/최소가 항상 고정된 위치에 존재
			- 최대/최소 원소는 항상 트리의 [루트]에 존재
			- 부모노드가 자식노드보다 항상 크거나 작아야한다.

		검색
			- 최대/최소 원소에 대해서만 가능 O(1)
		삽입
			- 완전이진트리 O(logN)
		삭제
			- 최대/최소 원소에 대해서만 가능 O(logN)
			
	트리는 연결자료구조로 많이 구현된다
		> 순차자료구조로 구현하면 수식을 이용해야한다
			- 완전트리가 아닌이상 메모리낭비가 매우 심하다 (2^level + 1) 공간필요
			- 하지만 힙은 배열로 구현한다. 낭비되는 메모리가 거의 없기때문에
		
해시테이블
	- 검색만을 위한 자료구조
		- 읽기 O(1)
		- 검색 O(1) espacially 빠름 이진탐색트리보다 빠름
			- 정렬된 경우 -> 이진탐색트리
			- 정렬?그딴거없음 -> 해시테이블
		- 삽입/삭제 O(1) ㅎㄷㄷ;;
	- 해싱 + 선형리스트의 특징을 사용
	- 선형리스트로 구현되어있고, 해싱을 이용해 인덱스를 구함
		> 해싱: 어떤 입력이 주어지든 고정된 길이의 출력으로 바꾸는것
			- 균일성: 충돌이적은것
				> 충돌: 서로 다른값이 같은 해시값 생성
			- 효율성: 겁나빠른 계산, 쉬운난이도
			- 결정적: 같은입력엔 같은값 <-> 비결정적: 무작위
	- 해싱의 성질을 이용해 인덱스를 구한다
	unordered 컨테이너 사용 <- 검색만을 위해 stl에 구현된 해시테이블
	
	- 충돌처리
		- 선형개방주소법
			- 충돌이 나면 빈공간을 찾아서 그곳에 넣는다
		- 체이닝
			- 충돌나면 리스트로 여러 값을 저장
	
	해시알고리즘 SHA256 -> 0 ~ 2^256  고정된 64개의 값으로 출력함
		> 참고사이트: http://cris.joongbu.ac.kr/course/2019-1/wp/crypto/hash.html
		
	- 해싱은 일방향성으로 해시값을 다시 입력값으로 바꿀순없다
	
	이러한 해시값을 인덱스로 쓰는게 해시테이블이다
	C#에서는 Dictionary에 구현되어있다
	
	
	
	
유니티는 범용그래픽엔진이다(게임뿐만아니라 영화, 디자인, 그림등 다양한곳에서 사용)
유니티 기본단위 씬
씬: 컨텐츠를 포함하여 작업하는 공간
유니티에 존재하는 모든 오브젝트: 게임오브젝트
